Field UI Rules (working notes)

Last updated: 2025-09-22
Scope: Conventions for Field’s UI (KnobCell/SwitchCell/Combo), Group 1 and Group 2 panels, labels, layout, performance.

---
Core Principles
- Consistency over cleverness: same label system and metrics across all knobs.
- Single source of truth: LNF draws captions from slider.setName(...).
- KnobCell owns value-label placement (Managed). Avoid external placement for KnobCell controls.
- Flattened grids: contiguous, gapless layout; fill space by design, not margins.

---
Controls: Captions and Value Labels
- Captions (names)
  - Set via slider.setName("CAP"). Short caps (2–6 chars): ER WID, TL WID, ER DEN, WET, SIZE, XO LO, XO HI, PUNCH, CNTR.
- Value labels
  - Use KnobCell::setValueLabelMode(Managed) and setValueLabelGap(...).
  - KnobCell positions value label under the knob in resized().
  - Initialize value label text once from current slider value.
- Precision guidelines
  - Frequency (HP/LP): 0 decimals (Hz). Percent: 0 decimals. dB: 1 decimal. Time: ms 0–2 decimals; seconds 2–3 sig figs.

---
KnobCell Metrics & Styling
- Metrics
  - Standard knob diameter = L; value band height = dp(14); label gap = dp(4).
  - DUCK strip (Reverb): DUCK/ATT/REL/THR/RAT use same metrics as other Reverb knobs.
- Minis & aux
  - Use KnobCell mini strip for micro sliders/bars (BOOST mini, Q-Link) with explicit thickness; prefer right-side placement when appropriate.
- LookAndFeel
  - Blue ticks at 12/3/6/9 via FieldLNF rotary drawing.
  - Metallic background for Group 1 center items and Motion Engine cells; Group 2 stays default.
  - Optional properties: panelBrighten, borderBrighten. Use sparingly.
  - Combo: tintedSelected to hide default label when custom captioning is used.

  - Tabs: active tab uses a static accent border (no animated glow). Any previous glow animation is removed.
  - Menus (PopupMenu): draw colours from LookAndFeel configured colourIds; do not hardcode whites/greys.

---
Panels, Grids, and Padding
- Group 1: flattened 4×16 grid (left/center/right merged); preserve exact ordering; close gaps.
- Group 2: flattened 4×16 grid using 8 columns; place items directly (no sub-containers). Build once; reflow only on size/scale changes (dirty flag).
- Gaps
  - rowGap = 0, columnGap = 0.
  - No outer reduced(...) around Group 2 layouts; items lay edge-to-edge with panel bounds.
- Cell width
  - Standard = L knob px + dp(8) across Delay/Reverb/Motion/Center.

---
Reverb Engine (Group 2)
- Abbreviations
  - ER WID (was ER WIDTH), TL WID (was WIDTH), ER DEN (was ER DENS).
- Ducking
  - DUCK + ATT/REL/THR/RAT standardized to main knob metrics.
  - GR arc in DUCK; grey-out on inactive.
- Wet/Enable UX
  - WET controls amount; Enable remains explicit. Optional auto-enable when WET>0, auto-bypass when WET=0.
- New controls
  - SIZE sizePct, DEC XO LO dreqXoverLoHz, DECAY (RT60) rt60Sec, BLOOM bloomPct, DISTANCE distancePct, FREEZE freezeOn, DEC XO HI dreqXoverHiHz.

---
Motion Engine (Group 1 only)
- Lives only in Group 1 flat grid; not parented in Group 2.
- All Motion knobs use KnobCell with Managed value labels.
- Ensure each Motion knob slider has setName(...) so LNF captions render.
- Theme-driven Motion colors (color-mode compliant):
  - Background gradient from theme.motionPanelTop/motionPanelBot.
  - Border from theme.motionBorder.
  - Property flag for styling: motionPurpleBorder (legacy motionGreenBorder still recognized but migrate away).
  - Motion ComboBoxes and Buttons adopt the same background/border via SwitchCell when the flag is set.

---
Attachments & Parameters
- Use slider/button/combo attachments created once and owned long-term.
- Do not create/destroy attachments in timers or frequent layout passes.
- Add migration logic in state load when moving legacy parameters.

---
Performance Guidance (avoid UI lag)
- Message thread
  - Never block: no file I/O, heavy JSON, or DSP on the UI thread; use background threads.
- Painting
  - Avoid expensive per-pixel noise/texture in paint() without caching. If using metallic/grain/scratches, pre-render to an Image.
  - Minimize layers/shadows/alpha per frame.
 - Timers & layout
  - Editor heartbeat (global): baseline ~30 Hz, bursts to ~60 Hz briefly on interaction.
  - Component timers (local): 0 Hz when hidden; 15–30 Hz when visible; 60 Hz only with profiling and tiny repaints.
  - Overlay (Group 2) policy: single animation driver (editor timer), move-only slide (adjust overlay Y), no per-frame grid reflow; children built once; reflow on size/scale only.
  - Avoid performLayout or reparenting in timers. Parent once; toggle visibility instead.
  - Visibility gating pattern for component timers:
    
    ```cpp
    class Foo : public juce::Component, private juce::Timer {
    public:
        Foo() { startTimerHz(30); }
        void visibilityChanged() override { if (isVisible()) startTimerHz(30); else stopTimer(); }
        void timerCallback() override { if (isShowing()) repaint(); }
    };
    ```
- Allocation churn
  - Avoid creating/destroying Components/Attachments during interaction/animation.
- Repaints
  - Repaint the smallest region necessary.

---
Discrepancies & Redundancies (to monitor/fix)
- Duplicate caption systems: remove external placeLabelBelow for knobs; standardize on slider.setName + KnobCell Managed.
- Metallic background drift: only Group 1 center cells and Motion Engine should be metallic; do not tint Group 2.
- Right-align/reduction remnants: ensure no stale right-align or reduced(...) in Group 2 layouts.
- Label coverage: audit all Motion/Center/Reverb knobs for setName(...); abbreviations per spec.
- Value label precision: HP/LP 0 decimals; dB 1 decimal; percent 0 by default.
- Punch Mode duplicate labels: prefer tintedSelected to suppress default Combo label when custom captioning is present.
- DUCK strip sizing: verify DUCK/ATT/REL/THR/RAT match other Reverb knobs in size and label band alignment.

---
Checklist for New Controls
- [ ] Create slider/button/combo + setName (caption).
- [ ] Attach to APVTS with persistent attachment.
- [ ] Wrap in KnobCell/SwitchCell; set metrics; set ValueLabelMode::Managed and label gap.
- [ ] Initialize the value label text once (format per type) before first paint.
- [ ] Place in the flat grid with explicit row/column; no row/column gaps.
- [ ] Apply group styling (metallic only in Group 1 center and Motion) via properties.
- [ ] Verify performance: no heavy work on UI thread; minimal repaints.

---
Notes
- Keep this document updated when patterns change or discrepancies are resolved.

---
UI Performance Practices (snappy drags, minimal lag)
- Component architecture
  - Create controls and APVTS attachments once; avoid creating/destroying or reparenting during interaction. Toggle visibility instead.
  - Prefer one canonical KnobCell/SwitchCell/Combo style; reduce per-control branching and custom code paths.
  - Set setOpaque(true) on components that fully paint their backgrounds to reduce compositor work.
- Painting and textures
  - Centralize paint logic in LNF/Cell helpers and keep it lightweight.
  - Cache heavy textures (metallic/brush/noise) to an Image per size/scale; reuse instead of regenerating per paint.
  - Repaint narrowly (only the control’s local bounds). Avoid triggering large parent repaints for small updates.
  - Prefer simple strokes/gradients; avoid randomization in paint paths during interaction.
  - Preallocate hot-path geometry: call Path::preallocateSpace for curves rebuilt each paint (e.g., EQ/Scope curves) to avoid per-frame allocations.
- Timers and updates
  - Keep component timers at 15–30 Hz for UI indicators; rely on editor heartbeat ~30 Hz with adaptive bursts to ~60 Hz on interaction (editor only). Never call performLayout or reparent in timers. Start/stop component timers based on visibility.
  - Batch non-critical updates; avoid string churn and label layout in mouse drag paths.
- Parameter/value plumbing
  - One attachment per control, owned long-term. Initialize value labels once before first paint; attachments update text only.
- Memory and allocations
  - Avoid allocations in paint/mouseDrag; pre-allocate Fonts/Paths/StringBuffers used repeatedly.
  - Cache LookAndFeel* at the start of paint and reuse within the scope.
- Layout
  - Use flat grids with fixed cell metrics and zero gaps. Avoid outer reductions/padding that trigger re-layout.
- Theme & color modes
  - Derive all colors from FieldLNF::theme (including Motion: motionPanelTop/motionPanelBot/motionBorder). No hardcoded hex in paint paths (replace with theme lookups + minimal hue/sat/alpha tweaks only when necessary).
  - Tint palettes must derive from FieldLNF::theme. It’s acceptable to apply small hue/saturation/brightness/alpha adjustments to theme colours for differentiation (e.g., menu item tints for modes/paths), but avoid fixed hex.
  - Examples:
    - Oversampling tints: use theme.eq.bass, theme.eq.scoop, and accent hue-shifts.
    - Phase/quality tints: use theme.eq.hp and accent hue offsets.
    - Path/quant/mode tints: compose from theme families (accent/eq.*) with minor hue/sat tweaks.

---
Audit System (how we audit UI performance & consistency)
Purpose: Regularly verify the entire plugin UI meets responsiveness, consistency, and theme-compliance standards without over-engineering.

What we audit (entire plugin)
- Consistency
  - All controls (EQ, Center, Delay, Reverb, Motion, meters) use canonical KnobCell/SwitchCell/Combo patterns with Managed value labels and slider.setName captions.
  - Legacy caption/placement systems removed (no external placeLabelBelow for KnobCell-managed controls).
  - Styling rules respected: metallic only for Group 1 center and Motion; Group 2 default background.
  - Border/theme flags used consistently per system: Reverb uses reverbMaroonBorder; Motion uses motionPurpleBorder (legacy motionGreenBorder allowed only for backward-compat); Delay uses delayThemeBorderTextGrey when intended.
- Theme compliance
  - No hardcoded hex colours in paint paths across the codebase; all colours derived from FieldLNF::theme (including Motion’s motionPanelTop/motionPanelBot/motionBorder).
  - Color mode changes (palette button) update visuals across all modules (EQ overlays, Center, Delay, Reverb, Motion, menus).
- Churn & layout
  - No component/attachment creation, deletion, or reparenting during drag/timer paths.
  - performLayout only on size/layout changes; not in timers.
  - No outer reduced(...) around active Group 2 grids.
- Paint cost
  - No per-paint randomization or heavy loops in hot controls; textures cached.
  - Repaint regions are minimal; no large parent repaints from child updates.
- Timers & updates
  - Timer frequencies within 15–30 Hz; no heavy work inside timer callbacks.
  - Labels initialized once; ongoing updates avoid re-layout.

How to run the audit (manual checklist)
1) Theme sweep
   - Cycle color modes (Ocean/Green/Pink/Yellow/Grey). Confirm Motion/Reverb/Center colors track theme values.
2) Interaction sweep
   - Drag representative knobs rapidly; observe for lag/hitches on start/stop. Ensure no component churn in logs.
3) Repaint scope
   - Turn on repaint highlighting/profiling (dev build). Verify only control bounds repaint during drags.
4) Timer scope
   - Disable meters/animations; confirm responsiveness. Re-enable at 15–30 Hz and confirm no stutter.
5) Code scan
   - Grep for hardcoded hex in UI paint paths; ensure theme usage. Grep for reparent/addAndMakeVisible in timers/drag handlers.
6) Texture cache
   - Confirm metallic/brush/noise cached; no per-paint random generation in hot paths.
7) Layout review
   - Verify flat grid bounds, zero gaps, and no outer reductions on Group 2 grids.

Pass criteria
- No frame hitches on rapid drags; repaint region is minimal; timers within target frequencies; zero hardcoded Motion colors; no runtime component churn.
